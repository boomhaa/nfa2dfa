# nfa2dfa

Программа для работы c конечными автоматами:

- читает **НКА** из `.dot` файла (Graphviz);
- строит эквивалентный **ДКА** (алгоритм подмножеств);
- минимизирует ДКА **двумя разными алгоритмами**:
  - табличный алгоритм (pairwise / table-filling),
  - алгоритм **Хопкрофта**;
- генерирует `.dot` файлы для полученных автоматов, которые можно визуализировать с помощью Graphviz.

## Требования

- Python 3.10+ (подойдёт и 3.8/3.9, если убрать аннотацию `str | None`, но по умолчанию ориентируемся на 3.10+);
- библиотек сторонних нет — используется только стандартная библиотека.

## Формат входного НКА (.dot)

Ожидается `.dot` примерно такого вида:

```dot
digraph NFA {
    rankdir=LR;
    node [shape=circle];

    __start [label="", shape=none];
    __start -> 0;

    21 [shape=doublecircle];

    0 -> 1 [label="a"];
    0 -> 2 [label="b"];
    0 -> 3 [label="c"];
    0 -> 4 [label="ε"];
    1 -> 0 [label="a"];
    2 -> 0 [label="b"];
    3 -> 0 [label="c"];
    ...
}
```

Правила:

- Стартовое состояние задаётся через специальный узел `__start`:

  ```dot
  __start [label="", shape=none];
  __start -> 0;
  ```

  Здесь `0` — стартовое состояние.

- Принимающие состояния задаются с атрибутом `shape=doublecircle`:

  ```dot
  21 [shape=doublecircle];
  ```

- Переходы задаются в виде:

  ```dot
  0 -> 1 [label="a"];
  19 -> 20 [label="a,b,c"];
  20 -> 21 [label="b,ε"];
  ```

  - Если в метке несколько символов, они разделяются запятой.
  - Epsilon-переход обозначается строкой `ε` (греческая буква эпсилон).
    Если в метке `b,ε`, это означает переход по `b` **и** ε-переход.

- Имена состояний должны быть «простыми» (как у Graphviz по умолчанию):
  числа (`0`, `1`, …) или идентификаторы из `\w` (латиница/цифры/подчёркивание).  
  Узел `__start` зарезервирован под стартовую стрелку и **не считается** состоянием НКА.

## Что делает программа

1. **Парсинг НКА** из `.dot`:
   - извлекает множество состояний;
   - определяет стартовое и принимающие;
   - строит таблицу переходов `transitions[state][symbol] = {next_states}`;
   - выделяет алфавит (все символы меток, кроме `ε`).

2. **Построение ДКА**:
   - реализован стандартный алгоритм подмножеств (subset construction);
   - состояния ДКА — множества состояний НКА;
   - в коде ДКА состояния перенумерованы `0..n-1`;
   - в поле `state_mapping` хранится отображение  
     `номер_состояния_ДКА -> множество состояний НКА`.

3. **Минимизация ДКА (2 алгоритма)**:
   - **Табличный алгоритм (pairwise / table-filling)**:
     - строится таблица различимости пар состояний;
     - помечаем пары (p, q), где один принимающий, другой — нет;
     - итеративно расширяем множество помеченных пар;
     - непомеченные пары объединяются в классы эквивалентности.

   - **Алгоритм Хопкрофта**:
     - стартовое разбиение: `F` (принимающие) и `Q \ F`;
     - далее итеративно делим классы, уточняя разбиение по обратным переходам;
     - результат — минимальный ДКА c асимптотикой `O(|Σ| * |Q| log |Q|)`.

   В обоих случаях:
   - ДКА предварительно дополняется до **полного** (добавляется поглощающее состояние `sink`);
   - неподходящие переходы ведут в `sink`;
   - после этого учитываются только **достижимые** состояния.

4. **Генерация `.dot`**:
   - для трёх автоматов:
     - исходный ДКА,
     - минимальный ДКА (табличный алгоритм),
     - минимальный ДКА (алгоритм Хопкрофта);
   - формат вывода:

     ```dot
     digraph DFA_MIN_TABLE {
         rankdir=LR;
         node [shape=circle];
         __start [label="", shape=none];
         __start -> 0;
         0 [shape=circle];
         1 [shape=doublecircle];
         ...
         0 -> 1 [label="a"];
         ...
     }
     ```

## Запуск

```bash
python main.py input.dot --out-prefix result
```

Где:

- `input.dot` — файл с НКА в формате, описанном выше;
- `--out-prefix result` — префикс для имён выходных файлов (по умолчанию `automaton`).

После запуска появятся файлы:

- `result_dfa.dot` — ДКА, построенный из исходного НКА;
- `result_min_table.dot` — минимальный ДКА (табличный алгоритм);
- `result_min_hopcroft.dot` — минимальный ДКА (алгоритм Хопкрофта).

## Визуализация

Для визуализации используй Graphviz. Например:

```bash
dot -Tpng result_dfa.dot -o dfa.png
dot -Tpng result_min_table.dot -o dfa_min_table.png
dot -Tpng result_min_hopcroft.dot -o dfa_min_hopcroft.png
```

## Замечания

- Оба алгоритма минимизации (табличный и Хопкрофта) дают **один и тот же по мощности** минимальный автомат.  
  Разница может быть только в названии состояний.
- Поглощающее состояние (`sink`) будет присутствовать в минимальном автомате, если оно необходимо для полноты ДКА.
- Во внутреннем представлении ДКА всегда нумеруется целыми числами `0..n-1`, но через `state_mapping` можно понять, каким множествам состояний НКА они соответствуют.
